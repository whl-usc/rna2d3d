"""
contact:    wlee9829@gmail.com
date:       2024_04_08
python:     python3.10
script:     isharc.py

This script assesses the overlap between duplex groups (DGs) arms generated by
CRSSANT and uses it to filter the iSHARC dataset for further analysis.
"""
# Define version
__version__="1.3.1"

# Version notes
__update_notes__="""
1.3.2
    -   Fixed the bedgraph output file naming.

1.3.1
    -   Added settings line for bedgraph output, naming based on input bedpe.
    -   Updated docstrings to reflect updated function logic.

1.3.0
    -   Fixed issues with confidence calcualation, now allows for multiple
        low confidence DG coverage removal rather than only the single lowest
        (See flag [-dg]).
1.2.1
    -   Updated some docstrings to clarify functions.
1.2.0
    -   Separated options for subtraction of "all" DG or the lowest
        confidence DG for function used to update coverage. 
1.1.0
    -   Changed to BAM input processing with .fetch() to speed up read
        coverage updating. 
1.0.0
    -   Added the initial function to determine overlap regions in bedpe,
        will be used to remove coverage from the iSHARC bam based on DG arms.
0.0.0
    -   Initial functions written for parsing input files.
"""

# Import packages
from datetime import datetime
import argparse
import os
import pysam
import re
import subprocess
import sys
import textwrap
import time

###########################################################################
# 1. Define common functions.
def timenow():
    """
    Current timestamp as a string.

    Returns:
        str: Current timestamp in format 'YYY-MM-DD HH:MM:SS'.
    """
    time = str(datetime.now())[:-7]

    return time

def collapse_gene_regions(annotation_file):
    """
    Defines gene region containing by parsing through a modified GTF
    annotation file. This function was written with the hg38 
    annotation in mind. See help section from the bamget.py script for
    details on preparing the modified annotation from a Gencode GTF file.

    Args:
        annotation_file: input annotation file with gene information.

    Returns:
        gene_regions (dict): gene names as keys, chromosome, start, stop
        information as values.
    """
    # Define valid chromosome names: chr(1-23, X, Y, M)
    valid_chromosomes = set([f"chr{i}" for i in range(1, 23)] + 
        ["chrX", "chrY", "chrM"] + [])
    gene_regions = {}
    with open(annotation_file, 'r') as f:
        for line in f:
            parts = line.split("\t")
            chromosome = parts[0].strip("'\"")
            if chromosome not in valid_chromosomes:
                chromosome = chromosome[3:]
            start = int(parts[1])
            stop = int(parts[2])
            strand = parts[3]
            gene_name = parts[4]

            if gene_name not in gene_regions:
                gene_regions[gene_name] = (chromosome, start, stop)
            else:
                gene_regions[gene_name] = (chromosome,
                    min(start, gene_regions[gene_name][1]), 
                    max(stop, gene_regions[gene_name][2]))

    return gene_regions

def parse_isharc(input_file, gene_regions, debug=False):
    """
    Reads the iSHARC data into a dictionary, filtering for coverage within
    the specific gene regions. 

    Args: 
        iSHARC bam: input sorted primary bam file after iSHARC mapping
        gene_regions: {gene: [chromosome, start, stop]}

    Returns:
        gene_coverage: {gene:{position: coverage}}
    """
    try:
        bamfile = input_file if input_file.endswith(".bam") \
            else f"{input_file[:-4]}.bam"
        
        if not bamfile.endswith(".bam"):
            subprocess.run(['samtools', 'view', '-bS', '-o', bamfile,
                input_file], check=True)

        subprocess.run(['samtools', 'index', bamfile], check=True)

    except Exception as e:
        error_message = (f"\nERROR: Failed to parse the provided file input."
            f" Check to see if file format is correct. Details: {e}.")
        print(error_message)
        sys.exit()

    bam = pysam.AlignmentFile(bamfile, "rb")
    total_genes = len(gene_regions); interval = total_genes // 10
    processed_genes = 0

    # Process reads and generate coverage
    gene_coverage = {}
    for gene, (gene_chrom, gene_start, gene_end) in gene_regions.items():
        try: gene_reads = bam.fetch(gene_chrom, gene_start, gene_end)
        except: pass
        # Process overlapping reads
        for read in gene_reads:
            start = read.reference_start
            end = read.reference_end
            # Ensure read overlaps with gene region
            if start <= gene_end and end >= gene_start:
                for pos in range(max(start, gene_start), 
                    min(end, gene_end) + 1):
                    gene_coverage.setdefault(gene, {})
                    gene_coverage[gene][pos] = \
                        gene_coverage[gene].get(pos, 0) + 1

        processed_genes += 1
        if not debug:
            if processed_genes % interval == 0:
                progress_percent = (processed_genes / total_genes) * 100
                rounded = round(progress_percent, -1)
                if rounded % 10 == 0:
                    print('.'*20 + f"{rounded:.2f}% processed" + '.'*20)

    bam.close()
    if debug: print('\n',gene_coverage,'\n') 
    return gene_coverage

def parse_bedpe(bedpe_file, debug=False):
    """
    Reads the bedpe file to determine the DG number, start/stop locations, 
    and coverage and writes into a dictionary

    Args: 
        bedpe_file: input bedpe file after CRSSANT assembly

    Returns:
        bedpe_dict: 
            {DG:[l_chr, l_start, l_end, r_chr, r_start, r_end, coverage,
            confidence]}
    """
    # Read bedpe file and process the lines into a dictionary.
    bedpe_dict = {} 
    with open(bedpe_file, 'r') as f:
        for line in f:
            fields = line.strip().split('\t')
            names = [name.strip() for name in fields[6].split(',')]
            key = '_'.join(names[:3])
            l_chr = str(fields[0]) # Chromosome of left arm
            l_start = int(fields[1]) # Start position of the left arm
            l_end = int(fields[2]) # End position of the left arm
            r_chr = str(fields[3]) # Chromosome of right arm
            r_start = int(fields[4]) # Start position of the right arm
            r_end = int(fields[5]) # End position of the right arm
            coverage = int(fields[7]) # Number of DGs at these arm locations
            confidence = float(names[-1]) # Extracting the DG confidence
            value = (l_chr, l_start, l_end,
                r_chr, r_start, r_end,
                coverage, confidence)
            bedpe_dict[key] = value

    if debug: print(bedpe_dict,'\n')
    return bedpe_dict

def coverage_isolation(gene_coverage, bedpe_dict, 
    method, dg_count, debug=False):
    """
    Score positions based on DG coverage. For the subtraction-based approach: 
    If a single arm (either left or right) overlaps a given position, 
    subtract DG coveragefrom iSHARC coverage. For the low_confidence cleanup 
    approach: If a single arm overlaps a position, keep the coverage value. 
    Only subtract by the lowest confidence DG(s) whenever there is an overlap
    of DG arms.

    Args: 
        bedpe_dict: {DG:[l_chr, l_start, l_end, 
                    r_chr, r_start, r_end, coverage]}
        gene_coverage: {gene:{position: coverage}}
        method: subtract OR confidence
    (optional)
        dg_count: number of low confidence DGs to update coverage by

    Returns:
        (updated) gene_coverage: {gene:{position: coverage}}
    """
    # Subtraction: Removes coverage based on all DG coverage
    if method == 'subtract':
        for dg_key, dg_data in bedpe_dict.items():
            (l_chr, l_start, l_end, r_chr, r_start, r_end, 
            coverage, _) = dg_data
            for gene in gene_coverage:
                for pos in range(l_start, l_end + 1):
                    if pos in gene_coverage[gene]:
                        gene_coverage[gene][pos] -= coverage
                for pos in range(r_start, r_end + 1):
                    if pos in gene_coverage[gene]:
                        gene_coverage[gene][pos] -= coverage

    # Confidence: subtract lowest conf DG coverage from gene_coverage.
    elif method == 'confidence':
        conf_pos = {}; low_conf_per_pos = {}          
        for dg_key, dg_data in bedpe_dict.items():
            (l_chr, l_start, l_end, r_chr, r_start, r_end, 
            coverage, confidence) = dg_data

            for position in range(l_start, r_end + 1):
                conf_pos.setdefault(position, []).append((dg_key, confidence))
                dg_info = (dg_key, coverage, confidence)
                if position not in low_conf_per_pos:
                    low_conf_per_pos[position] = [dg_info]
                else:
                    low_conf_per_pos[position].append(dg_info)

        # Iterate through position with multiple confidence values
        num_low_conf_pos = int(dg_count)
        for position, dg_info_list in conf_pos.items():
            if len(dg_info_list) > 1:
                # Sort low_conf_per_pos by conf, get lowest conf
                sorted_dg_info = sorted(dg_info_list, key=lambda x: x[1]) 
                lowest_conf_dg_info = sorted_dg_info[:num_low_conf_pos]
                # Subtract coverage by lowest confidence DGs
                for dg_key, _ in lowest_conf_dg_info:
                    coverage = bedpe_dict[dg_key][-2] # Coverage values
                    for gene, positions in gene_coverage.items():
                        if position in positions:
                            gene_coverage[gene][position] -= coverage
                            break

    else:
        print(f"Method must either be 'subtract' or 'confidence'.")
        sys.exit()
    
    if debug: print(gene_coverage,'\n')
    return(gene_coverage)

def optimized_coverage_isolation(gene_regions, gene_coverage, bedpe_dict,
    method, dg_count, debug=False):
    """
    Optimized versions of the functions that score positions based on DG
    coverage. For the subtraction-based approach: If a single arm (either 
    left or right) overlaps a given gene/chromosome position, subtract DG
    coverage from iSHARC coverage. For confidence cleanup approach: If a
    single arm overlaps a position, keep the coverage value, only subtracting
    by the lowest confidence DG(s) whenever there is an overlap of DG arms.

    Args: 
        gene_regions: {gene: [chromosome, start, stop]}
        gene_coverage: {gene:{position: coverage}}
        bedpe_dict: {DG:[l_chr, l_start, l_end, 
                    r_chr, r_start, r_end, coverage]}
        method: subtract OR confidence
    (optional)
        dg_count: number of low confidence DGs to update coverage by

    Returns:
        (updated) gene_coverage: {gene:{position: coverage}}
    """
    # Subtraction: Removes coverage based on all DG coverage
    if method == 'subtract':
        gene_regions_by_chr = {}
        for gene, (chr, start, end) in gene_regions.items():
            gene_regions_by_chr.setdefault(chr, []).append((gene, start, end))
        gene_coverage_set = {(gene, pos) for gene, 
            positions in gene_coverage.items() for pos in positions}

        for dg_key, dg_data in bedpe_dict.items():
            (l_chr, l_start, l_end, r_chr, r_start, r_end, 
            coverage, _) = dg_data

            if l_chr in gene_regions_by_chr:
                for gene, start, end in gene_regions_by_chr[l_chr]:
                    if l_start <= end and l_end >= start:
                        for pos in range(max(l_start, start), 
                            min(l_end, end) + 1):
                            if (gene, pos) in gene_coverage_set:
                                gene_coverage[gene][pos] -= coverage

            if r_chr in gene_regions_by_chr:
                for gene, start, end in gene_regions_by_chr[r_chr]:
                    if r_start <= end and r_end >= start:
                        for pos in range(max(r_start, start), 
                            min(r_end, end) + 1):
                            if (gene, pos) in gene_coverage_set:
                                gene_coverage[gene][pos] -= coverage

    # Confidence: subtract lowest conf DG coverage from gene_coverage.
    elif method == 'confidence':
        pass

    else:
        print(f"Method must either be 'subtract' or 'confidence'.")
        sys.exit()

    if debug: print(gene_coverage,'\n')
    return(gene_coverage)

def cov_to_bed(gene_coverage, gene_regions, output):
    """
    Args: 
        gene_coverage: {gene:{position, coverage}}

    Returns:
        bedgraph: [gene, start, stop, coverage]
    """
    bedgraph = [[gene_regions[gene][0], pos - 1, pos, coverage]
        for gene, positions in gene_coverage.items()
        for pos, coverage in positions.items()]

    outfile = (output+'.bedgraph')
    with open(outfile, 'w') as f:
        f.write(f'track type=bedGraph autoscale=on, visibility=full, '
        f'color=255,0,0, altColor=0,0,255, priority=20, viewLimits=0:1000\n')
        for row in bedgraph:
            f.write('\t'.join(map(str, row)) + '\n')

###########################################################################
# 2. Main, define accepted arguments. 

def parse_args():
    """
    Parse the command-line arguments.
    """
    parser = argparse.ArgumentParser(
        prog="isharc.py",
        formatter_class=argparse.RawTextHelpFormatter,
        description=textwrap.dedent("""\
###########################################################################

A script to re-evaluate iSHARC coverage based on the overlaps defined in DG
arms produced by CRSSANT analysis. Output is written to a bedgraph file that
can be directly visualized in IGV.

NOTE: Arguments must be provided in the following order:

1. annotation:      Annotation file (path) containing gene regions in
                    modified GTF format:

                    chrom   chrom_start   chrom_end   gene_name   strand

                    The modified GTF can be generated using a gencode 
                    annotation file and the following commands:

                    zcat gencode.v45.basic.annotation.gtf.gz
                    awk -F'\\t '$3 == "gene" && $9 ~ /gene_type 
                    "protein_coding"/ && $9 !~ /gene_name "ENSG0000"/ 
                    {split($9, a, "\\""); print $1 "\\t" $4 "\\t" $5 "\\
                    t" a[6] "\\t" $7}' > annotation.bed

                    If providing a pre-made annotation file, the format 
                    must follow the tab-separated columns described above.

                    NOTE: Specific genomic regions or RNAs are masked and 
                    added back as a separate 'chromosome' in the PARIS
                    SHARC pipelines. These must manually be added as
                    separate lines to the annotation_file. Always check 
                    to see if the chromosomes are in the output BED6 files
                    generated using this script.

                    List of genes to be added as a separate 'chromosome':
                    ---------------------------------
                    RN7SK   1       331     RN7SK   +
                    RN7SL   1       288     RN7SL   +
                    RNU7    1       63      RNU7    +
                    RNY     1       112     RNY1    +
                    RNY     213     314     RNY2    +
                    RNY     415     510     RNY3    +
                    RNY     611     694     RNY4    +
                    U13     1       120     U13     +
                    U14AB   1       92      U14A    +
                    U14AB   193     283     U14B    +
                    U17     1       207     U17     +
                    U3      1       217     U3      +
                    U8      1       136     U8      +
                    hs12S   1       954     12S     +
                    hs16S   1       1559    16S     +
                    hs45S   3654    5523    18S     +
                    hs45S   6600    6757    5.8S    +
                    hs45S   7924    12994   28S     +
                    hs5S    1       121     hs5S    +
                    hssnRNA 1       164     U1      +
                    hssnRNA 265     451     U2      +
                    hssnRNA 552     696     U4      +
                    hssnRNA 797     902     U6      +
                    hssnRNA 1003    1118    U5      +
                    hssnRNA 1219    1353    U11     +
                    hssnRNA 1454    1603    U12     +
                    hssnRNA 1704    1833    U4atac  +
                    hssnRNA 1934    2058    U6atac  +
                    ---------------------------------

2. isharc_file:     Intended as PATH of the pri_sorted.bam file generated 
                    after the mapping.sh script from the rna2d3d pipeline is
                    used. However, any SAM or BAM file can be provided for 
                    determining read coverage.

3. bedpe_file:      The PATH of the *.bedpe file generated after CRSSANT 
                    analysis (DG assembly) is complete.

4. method:          "confidence" or "subtraction"

                    Defines the coverage scoring method. Use total subtraction
                    based method instead of partial updating based on lowest 
                    DG coverage. For reads with overlapping positions, iSHARC 
                    read coverage is subtracted by the total number of DG 
                    coverage. This is only recommended for iSHARC reads at 
                    high coverage and sparsely populated DG data.

OPTIONAL ARGUMENTS:

-dg, --dg_count:    Sets number of low confidence DGs to remove coverage by.
                    Defaults to [1], removing only reads from the lowest
                    confidence DG. If no reads overlap, then no DG coverage
                    will be removed.

###########################################################################
            """),
    usage=
"""\
\npython3 %(prog)s annotation iSHARC CRSSANT method [-dg]
""")
    parser.add_argument('annotation', 
        help='PATH to annotation bed file.')
    parser.add_argument('isharc_file', 
        help='PATH to iSHARC data file, provided in BAM format.')
    parser.add_argument('bedpe_file', 
        help='PATH to the .bedpe file generated by CRSSANT analysis')
    parser.add_argument('method',
        help='Either "confidence" or "subtract" to clean up coverage.')
    parser.add_argument('-dg', '--dg-count', type=int, default=1,
        metavar='NUM', help='DG count, defaults to [1] if not provided.' )
    parser.add_argument('-debug', '--debug', action='store_true', 
        help='Prints debug messages.')
    return parser.parse_args()

def main():
    start_time = time.time()
    print(timenow(), "Starting analysis of DG file.")

    annotation = args.annotation
    isharc_bam = args.isharc_file
    bedpe = args.bedpe_file

    # Check for optional arguments
    method = args.method
    dgs = 1 if not args.dg_count else int(args.dg_count)

    if not args.debug: 
        print(timenow(), f"Collecting gene regions from {annotation}...")
    gene_regions = collapse_gene_regions(annotation)

    if not args.debug: 
        print(timenow(), f"Filtering coverage based on gene regions...\n")
    gene_coverage_dict = parse_isharc(isharc_bam, gene_regions, args.debug)

    if not args.debug: 
        print("\n" + timenow(), 
        f"Updating coverage scores based on DG overlaps...\n")
    bedpe_dict = parse_bedpe(bedpe, args.debug)
    # new_coverage = coverage_isolation(gene_coverage_dict, bedpe_dict,
       # method, dgs, args.debug)
    new_coverage = optimized_coverage_isolation(gene_regions, 
        gene_coverage_dict, bedpe_dict, method, dgs, args.debug)

    if '_pri_crssant_' in bedpe: 
        output = bedpe.split('.cliques')[0]
    else:
        output = os.path.splitext(str(bedpe))[0]

    # cov_to_bed(new_coverage, gene_regions, output)

    end_time = time.time()
    elapsed_time = "{:.2f}".format(end_time - start_time)

    if not args.debug: 
        print(timenow(), f"Job completed in {elapsed_time}\n")

if __name__ == "__main__":
    args = parse_args()
    main()
    sys.exit()