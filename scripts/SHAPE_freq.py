"""
minjiezhang123@gmail.com    2020-12-16      python 3

"""


#1. input and output setup
################################################################################
################################################################################
#this section sets up the input and output
import sys, argparse, numpy, os, re, itertools, random, math, pysam
from datetime import datetime
from sklearn.metrics import roc_curve, auc
import matplotlib as mpl  
import matplotlib.pyplot as plt
from math import floor, ceil
from collections import Counter
from Bio.PDB.PDBParser import PDBParser

if len(sys.argv) < 3:
    print("Usage:           python SHAPE_freq.py sam_crssant  shape_bedpragh  DG_reads_cutoff  DGcommon_ratio  seqlen  extendlen  DG/reads  outputprefix")
    print("sam_crssant:     sam file generated by crssant.py")
    print("shape_bedpragh:  shape activity of each nucleotides, in bedgraph format")
    print("DG_reads_cutoff: minimum reads number of each DG")
    print("DGcommon_ratio:  minimum ratio to call the common region of each DG")
    print("seqlen:          how many nts before 3' end")
    print("extendlen:       how many nts after 3' end")
    print("DG/reads:        'DG' or 'reads' used for analysis")
    print("outputprefix                                     ")
    sys.exit()

inputsam = open(sys.argv[1],'r')
arcfile = open(sys.argv[2],'r')
minreads = int(sys.argv[3])
DGcommoncutoff = float(sys.argv[4])
seqlen = int(sys.argv[5])
extendlen = int(sys.argv[6])
DGorReads = sys.argv[7]
#fasta = sys.argv[8]
#ref=pysam.FastaFile(fasta)
outprefix = sys.argv[8]

################################################################################


#2. subfunctions
################################################################################
def timenow(): return str(datetime.now())[:-7]

def mergeCIGAR(CIGAR): 
    #merge all operations that consume the reference, i.e. MI=X
    #example: 1S2M3N4M5I6M7S -> 1S2M3N10M7S 
    ops = re.findall('\d+[MNISH=X]', CIGAR) #all that consume query
    newops = [ops[0]]
    for op in ops[1:]: #concatenate all internal ops that consume query [MIS=X
        if op[-1] not in "I=X":
            if newops[-1][-1]=="M" and op[-1]=="M":
                newops[-1] = str(int(newops[-1][:-1])+int(op[:-1]))+"M"
            else: newops.append(op)
    newCIGAR = ("".join(str(i) for i in newops))
    return newCIGAR

def getsegs(line, segs): #turn an alignment into segs [(RNAME, STRAND L, R), ...]
    align = line.split()
    RNAME, POS, CIGAR = align[2], int(align[3]), align[5]
    STRAND = '-' if '{0:012b}'.format(int(align[1]))[-5] == '1' else '+'
    if align[0] not in segs: segs[align[0]] = [] #store all gaps from this CIGAR string, each as a 3-tuple.
    seglens = [int(i[:-1]) for i in re.findall('[0-9]+M', mergeCIGAR(CIGAR))] #seg lengths
    Ns =[i.rstrip('0123456789') for i in mergeCIGAR(CIGAR).split('M')]
    rx = [] #reference consumed: MD=X
    for N in Ns:
        rx.append(sum([int(i[:-1]) for i in re.findall('[0-9]+[ND=X]', N)]))
    for i in range(len(seglens)): #combine ref and segment lengths to make the junctions
        l, r = POS+sum(rx[:i+1])+sum(seglens[:i]), POS+sum(rx[:i+1])+sum(seglens[:i+1])-1
        if (RNAME, int(l), int(r), STRAND) not in segs[align[0]]: segs[align[0]].append((RNAME, int(l), int(r), STRAND))
        segs[align[0]].sort()
    #print(segs[align[0]])
    if len(segs[align[0]]) == 2: return segs[align[0]]

def normdist(list1,list2):
    mu1=np.mean(list1); sigma1 =np.std(list1)
    mu2=np.mean(list2); sigma2 =np.std(list2)
    overlap = NormalDist(mu1, sigma1).overlap(NormalDist(mu2, sigma2))
    return overlap

def getDGspan(DGspan):
    #DGspan['12S,12S,0']=[[('hs12S','2','22','+'),('hs12S','270','295','+')], [('hs12S','3','24','+'),('hs12S','285','300','+')]]
    #DGspan['12S,12S,1']=[[('hs12S', 8, 20, '+'), ('hs12S', 108, 137, '+')], [('hs12S', 6, 24, '+'), ('hs12S', 106, 145, '+')]]
    for DG in DGspan:
        DGslist=DGspan[DG]
        #print(DG)
        #print(DGspan[DG][0],DGspan[DG][-1])
        segls, segle, segrs, segre = int(DGslist[0][0][1]), int(DGslist[0][0][2]), int(DGslist[0][1][1]), int(DGslist[0][1][2])
        for i in range(1,len(DGslist),1):
            if int(DGslist[i][0][1]) < segls: segls=int(DGslist[i][0][1])
            if int(DGslist[i][0][2]) > segle: segle=int(DGslist[i][0][2])
            if int(DGslist[i][1][1]) < segrs: segrs=int(DGslist[i][1][1])
            if int(DGslist[i][1][2]) > segre: segre=int(DGslist[i][1][2])
        DGspan[DG]=[[DGslist[0][0][0],segls,segle,segle-segls+1],[DGslist[0][1][0],segrs,segre,segre-segrs+1]]
    return DGspan

def getOverlap(a, b):
    overlap = int(min(int(a[2]),int(b[2]))) - int(max(int(a[1]),int(b[1])))
    readslen = (int(b[2]) - int(b[1]))/2
    if overlap >1 and overlap >= readslen: seganno = "Ture"
    else: seganno = "False"
    return seganno

def coveragenorm(dglist,dgspan,cutoff):
    #dglist: [[chr1,1,15,+],[chr1,31,45,+]], [[chr1,2,13,+],[chr1,33,43,+]], [[chr1,5,20,+],[chr1,40,50,+]]...
    #dgspan: [[chr1,1,25,25],[chr1,30,50,25]]]
    #cutoff: 0.8
    dgspannew=[]; count=-1
    for arm in dgspan:
        poscoverage = {};
        dgstart=0; dgend=0; count+=1
        for i in range(int(arm[1]),int(arm[2])+1,1): poscoverage[i] = 0 #initialize the pos coverage

        for seg in dglist:
            if getOverlap(arm, seg[count]) == "Ture":
                for i in range(int(seg[count][1]),int(seg[count][2])+1,1): poscoverage[i] += 1
        for i in range(int(arm[1]),int(arm[2])+1,1):
            if poscoverage[i]/max(poscoverage.values()) >= cutoff:  dgstart = i; break;
        for i in range(int(arm[2]),int(arm[1]),-1):
            if poscoverage[i]/max(poscoverage.values()) >= cutoff:  dgend = i; break;

        len = dgend - dgstart + 1
        dgspannew.append([arm[0],str(dgstart),str(dgend), seg[count][3]])
    return dgspannew

"""
dglist=[[['chr1',1,15,'+'],['chr1',31,45,'+']], [['chr1',2,13,'+'],['chr1',33,43,'+']], [['chr1',5,20,'+'],['chr1',40,50,'+']]]
dgspan=[['chr1','1','25','25'],['chr1','30','50','25']]
cutoff=0.6
print(coveragenorm(dglist,dgspan,cutoff))
output: [['chr1', '2', '15', '14', '+'], ['chr1', '33', '45', '11', '+']]
"""
"""
dglist=[[('hs45S', 11867, 11894, '+'), ('hs45S', 11965, 11990, '+')], [('hs45S', 11874, 11901, '+'), ('hs45S', 11961, 11973, '+')], [('hs45S', 11872, 11886, '+'), ('hs45S', 11977, 11991, '+')], [('hs45S', 11874, 11898, '+'), ('hs45S', 11954, 11972, '+')], [('hs45S', 11875, 11903, '+'), ('hs45S', 11952, 11970, '+')], [('hs45S', 11875, 11896, '+'), ('hs45S', 11965, 11986, '+')], [('hs45S', 11875, 11890, '+'), ('hs45S', 11967, 11985, '+')], [('hs45S', 11877, 11903, '+'), ('hs45S', 11948, 11967, '+')], [('hs45S', 11867, 11883, '+'), ('hs45S', 11976, 11991, '+')], [('hs45S', 11867, 11885, '+'), ('hs45S', 11973, 11990, '+')], [('hs45S', 11867, 11885, '+'), ('hs45S', 11972, 11990, '+')]]
dgspan=[['hs45S', 11832, 11925, 94], ['hs45S', 11927, 12039, 113]]
cutoff=0.8
print(dglist)
print(dgspan)
print(coveragenorm(dglist,dgspan,cutoff))
"""

#bed1 [chr,14,23] -> [3:11-15; 4:16-20; 5:21-25]
#bed2 [chr,23,45] -> [5:21-25; 6:26-30; 7:31-35; 8:36-40; 9:41-45]
#out: [(3, 6), (4, 7), (5, 8)]
def getPos(bed1, bed2, winbin,start):
    chr1, start1, end1 = bed1[0], int(bed1[1])-int(start)+1, int(bed1[2])-int(start)+1
    chr2, start2, end2 = bed2[0], int(bed2[1])-int(start)+1, int(bed2[2])-int(start)+1
    pos1 = []; pos2 = []; pos1new = []; pos2new = []
    for i in range(ceil(start1/winbin), ceil(end1/winbin)+1, 1):
        pos1.append(i)
    for i in range(ceil(start2/winbin), ceil(end2/winbin)+1, 1):
        pos2.append(i)
    if len(pos1) >= len(pos2):
        max = len(pos1); min = len(pos2)
        start = int((max-min)/2);   end = start + min
        pos1new = pos1[start:end];  pos2new = pos2
    else:
        max = len(pos2); min = len(pos1)
        start = int((max-min)/2);   end = start + min
        pos1new = pos1;  pos2new = pos2[start:end][::-1]
    return list(zip(pos1new, pos2new))

def DNA_complement1(sequence):
    comp_dict = {"A":"T","T":"A","G":"C","C":"G","a":"t","t":"a","g":"c","c":"g"}
    sequence_list = list(sequence)
    sequence_list = [comp_dict[base] for base in sequence_list]
    string = ''.join(sequence_list)
    return string

def getfa(bed,ref):
    #bed: [chr1,12,25,+]
    RNAME,fastart,faend,STRAND = bed[0], bed[1], bed[2], bed[3]
    faseq = ''
    if STRAND == '+': faseq = ref.fetch(RNAME, int(fastart)-1, int(faend))
    if STRAND == '-': faseq = (DNA_complement1(ref.fetch(RNAME, int(fastart)-1, int(faend))))[::-1]
    return faseq.replace("T", "U")

# get dsRNA DGs
def DGinbp(newDGspan, bpinfo):
    DG_bp = {}
    # newDGspan:    {'1HR2,1HR2,0': [['1HR2', '2', '9', '+'], ['1HR2', '28', '33', '+']]}
    # bpinfo:   [[1HR2, 6, 112], [1HR2, 7, 111]...]
    for DG in newDGspan:
        for bp in bpinfo:
            if str(newDGspan[DG][0][0])==str(bp[0]) and str(newDGspan[DG][1][0]) == str(bp[0]):
                if int(bp[1]) in [i for i in range(int(newDGspan[DG][0][1]),int(newDGspan[DG][0][2]))]:
                    if int(bp[2]) in [i for i in range(int(newDGspan[DG][1][1]),int(newDGspan[DG][1][2]))]:
                        DG_bp[DG] = newDGspan[DG]
                        leftarm = getfa(newDGspan[DG][0],ref); rightarm = getfa(newDGspan[DG][1],ref);
                        DG_bp[DG].append(leftarm+'\t'+rightarm)
                        break
    return DG_bp

## test whether bed1 was included by bed2:
def bedinregions(bed, regions):
    # bed = ['hs45S', '3998', '4012', '+']
    # regions = [['hs45S', '3654', '5523'], ['hs45S', '6600', '6757'], ['hs45S', '7924', '12994']]
    bedanno = 'False'
    for targetbed in regions:
        if str(bed[0]) == str(targetbed[0]):
            if int(bed[1]) >= int(targetbed[1]) and int(bed[2]) <= int(targetbed[2]):
                bedanno = 'True'
                #print(bedanno)
                continue
    return bedanno

## get newDGspan with two arms located in target regions:
# newDGspan:    {'1HR2,1HR2,0': [['1HR2', '2', '9', '+'], ['1HR2', '28', '33', '+']]}
def get_targetDG(newDGspan, targetregion):
    #targetregion: hs45S:3654:5523,hs45S:6600:6757,hs45S:7924:12994
    regions = []; newDGspan_filter = {}
    for i in targetregion.split(','): regions.append(i.split(':'))
    for DG in newDGspan:
        if bedinregions(newDGspan[DG][0], regions) == 'True' and bedinregions(newDGspan[DG][1], regions) == 'True':
            if DG not in newDGspan_filter: newDGspan_filter[DG] = []
            newDGspan_filter[DG] = newDGspan[DG]
    return newDGspan_filter

# get arm seq
def get_aver_shapevalue(newDGspan, shapevalue, seqlen, extendlen):
    # newDGspan:    {'1HR2,1HR2,0': [['1HR2', '2', '9', '+'], ['1HR2', '28', '33', '+']]}
    leftarm = {};   rightarm = {};     leftarm_aver = [];     rightarm_aver = []; 
    for i in range(1, int(seqlen)+int(extendlen)+1, 1):   leftarm[i] = []; rightarm[i] = [];
    for DG in newDGspan:
        count = 0; arm_key = 0
        if str(newDGspan[DG][0][0])=='hs45S' and str(newDGspan[DG][1][0])=='hs45S':
            for i in range(0, seqlen+extendlen, 1):
                arm_key=int(seqlen)+int(extendlen)+count;
                #left arm
                if int(newDGspan[DG][0][2])+extendlen+count >= int(newDGspan[DG][0][1]):
                    leftarm[arm_key].append(shapevalue[int(newDGspan[DG][0][2])+extendlen+count])
                #right arm
                if int(newDGspan[DG][1][2])+extendlen+count >= int(newDGspan[DG][1][1]):
                    rightarm[arm_key].append(shapevalue[int(newDGspan[DG][1][2])+extendlen+count])
                count -= 1;

    #calculate the average value
    for i in range(1, int(seqlen)+int(extendlen)+1, 1):
        leftarm_aver.append(str(round(numpy.mean(leftarm[i]),2)))
        rightarm_aver.append(str(round(numpy.mean(rightarm[i]),2)))

    return leftarm_aver,rightarm_aver
################################################################################

## read shape data
################################################################################
shapevalue = {} #{pos: value ...}
for line in arcfile:
    #track graphType=arc
    #1HR2    6       112     0.98
    chr, start, end, value = line.rstrip('\n').split('\t')
    if float(value) >= 0:   shapevalue[int(end)] = float(value)
    else:   shapevalue[int(end)] = 0
arcfile.close()

## add value 0 to negative position
for i in range(1, 13358, 1):
    if i not in shapevalue: shapevalue[i] = 0
#print(shapevalue)

#3 start processing the sam file.
################################################################################
logfile = open(outprefix + 'log.out', 'w')
logstr = timenow()+" Started exo.py ...\n"
logstr += (timenow()+" Collecting alignments into a dictionary ...")
logfile.write(logstr+'\n');  print(logstr,)
dgdict = {}; #{sample-dgid: [(RNAME, str(ls), str(le), STRAND),(RNAME, str(rs), str(re), STRAND)] [] []..}
DGspan = {}; DGs=[];  segs={}; newDGspan = {}; newDGspan_filter = {}

if DGorReads == "DG":
    for line in inputsam:
        #build the dgdict: dictionary of all segment terminals
        #format: dgid:[RNAME, STRAND, lstart, lend, rstart rend]
        if line[0]=='@': continue
        align = line.split('\t')
        dgloc = len(align); dgid = None #check where the dgid is
        if align[dgloc-2][:2]=='DG': dgid = (align[dgloc-2].split(':')[-1])
        else: sys.exit("Error, DG ID not found in column 19")
        sample = align[0].split('-')[-1]
        if dgid not in DGs: DGs.append(dgid)
        dgid_sample = sample+'-'+dgid

        if dgid not in dgdict: dgdict[dgid]=[] #initialize the item
        if getsegs(line,segs):  dgdict[dgid].append(getsegs(line,segs))
        if dgid not in DGspan: DGspan[dgid]=[]
        if getsegs(line,segs):  DGspan[dgid].append(getsegs(line,segs))
    inputsam.close()

    ## get DGspan of raw data
    DGspan = getDGspan(DGspan)
    #print(DGspan)

    ## get the common region of each DG
    for DG in DGspan:
        if len(dgdict[DG]) >= minreads:  # filter DG based on DG_reads_cutoff parameter
            newDGspan[DG] = coveragenorm(dgdict[DG],DGspan[DG],DGcommoncutoff)
    DGspan = {}
    #print(newDGspan)

if DGorReads == "reads":
    for line in inputsam:
        #build the dgdict: dictionary of all segment terminals
        #format: dgid:[RNAME, STRAND, lstart, lend, rstart rend]
        if line[0]=='@': continue
        align = line.split('\t')
        readID = align[0]
        if readID not in newDGspan: newDGspan[readID] = []
        if getsegs(line,segs):  newDGspan[readID] = getsegs(line,segs)
    inputsam.close()

## filter newDGspan that located in target regions:
newDGspan_filter = get_targetDG(newDGspan, 'hs45S:3654:5523,hs45S:6600:6757,hs45S:7924:12994')
newDGspan = {}

leftarm_ave, rightarm_ave = get_aver_shapevalue(newDGspan_filter, shapevalue, seqlen, extendlen)

print('Total analyzed DG/reads:\t'+str(len(newDGspan_filter)))
print('left_arm\t'+'\t'.join(leftarm_ave))
print('rightarm\t'+'\t'.join(rightarm_ave))
