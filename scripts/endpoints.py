'''
contact:    wilsonhl@usc.edu
date:       2021_11_11
python:     python3.8
script:     endpoints.py
    
This script is used to determine the endpoints of DGs 
generated by CRSSANT, printing to file for further analysis.
User can specify the coverage in line 142.

'''

# Import packages
import sys, argparse, fileinput, numpy, os, re, itertools, random, math, csv, string
import pandas as pd
from collections import Counter

if len(sys.argv)<2:
    print("Usage:   python3 endpoints.py input.sam")
    sys.exit()

# Open the file for analysis, modification to remove header. 
sam_input = sys.argv[1]
sam_mod = os.path.splitext(sam_input)[0]
sam_nohead = sam_mod+"_nohead.sam"
with open(sam_input) as f: lines = f.readlines()
with open(sam_nohead, 'w') as f:
	for line in lines:
		if not line.startswith('@'): f.write(line)
with open(sam_nohead) as f: lines = f.readlines()
f.close()

# Parse .sam file to see how many DGs are in the file.
df = pd.read_csv(sam_nohead, sep="\t")
dg_counter = str(df.iloc[-1,19]).split(','); dg_num = dg_counter[-1]

# Functions used for analysis

# Merge CIGAR strings with multiple matches on one side 
def mergeCIGAR(CIGAR): 
    #merge all operations that consume the reference, i.e. MI=X
    #example: 1S2M3N4M5I6M7S -> 1S2M3N10M7S 
    ops = re.findall('\d+[MNISH=X]', CIGAR) #all that consume query
    newops = [ops[0]]
    for op in ops[1:]: #concatenates all internal ops that consume query [MIS=X
        if op[-1] not in "I=X":
            if newops[-1][-1]=="M" and op[-1]=="M":
                newops[-1] = str(int(newops[-1][:-1])+int(op[:-1]))+"M"
            else: newops.append(op)
    newCIGAR = ("".join(str(i) for i in newops))
    return newCIGAR

# Get information on read segments
def getsegs(line, segs): #turn an alignment into segs [(RNAME, STRAND L, R), ...]
    align = line.split()
    RNAME, POS, CIGAR, DG = align[2], int(align[3]), align[5], align[19]
    STRAND = '+'
    if align[0] not in segs: segs[align[0]] = [] #store all gaps from this CIGAR string, each as a 3-tuple.
    seglens = [int(i[:-1]) for i in re.findall('[0-9]+M', mergeCIGAR(CIGAR))] #seg lengths
    Ns =[i.rstrip('0123456789') for i in mergeCIGAR(CIGAR).split('M')]
    rx = [] #reference consumed: MD=X
    for N in Ns:
        rx.append(sum([int(i[:-1]) for i in re.findall('[0-9]+[ND=X]', N)]))
    for i in range(len(seglens)): #combine ref and segment lengths to make the junctions
        l, r = POS+sum(rx[:i+1])+sum(seglens[:i]), POS+sum(rx[:i+1])+sum(seglens[:i+1])-1
        if (RNAME, int(l), int(r), STRAND, int(re.findall('[^\,]+$', align[19])[0])) not in segs[align[0]]: segs[align[0]].append((RNAME, int(l), int(r), STRAND, int(re.findall('[^\,]+$', align[19])[0])))
        segs[align[0]].sort()
    #print(segs[align[0]])
    if len(segs[align[0]]) == 2: return segs[align[0]]

def getOverlap(a, b): 
    overlap = int(min(int(a[2]),int(b[2]))) - int(max(int(a[1]),int(b[1])))
    #readslen = (int(b[2]) - int(b[1]))/2
    if overlap >= 1: seganno = "True"
    else: seganno = "False"
    return seganno

def coveragenorm(dglist,dgspan,cutoff):
    #dglist: [[chr1,1,15,+],[chr1,31,45,+]], [[chr1,2,13,+],[chr1,33,43,+]], [[chr1,5,20,+],[chr1,40,50,+]]...
    #dgspan: [[chr1,1,25,25],[chr1,30,50,25]]]
    #cutoff: 0.1
    dgspannew=[]; count=-1
    for arm in dgspan:
        poscoverage = {};
        dgstart=0; dgend=0; count+=1
        for i in range(int(arm[1]),int(arm[2])+1,1): poscoverage[i] = 0 #initialize the pos coverage
        for seg in dglist:
            if getOverlap(arm, seg[count]) == "True":
                for i in range(int(seg[count][1]),int(seg[count][2])+1,1): poscoverage[i] += 1
        for i in range(int(arm[1]),int(arm[2])+1,1):
            if poscoverage[i]/max(poscoverage.values()) >= cutoff:  dgstart = i; break;
        for i in range(int(arm[2]),int(arm[1]),-1):
            if poscoverage[i]/max(poscoverage.values()) >= cutoff:  dgend = i; break;
        len = dgend - dgstart + 1
        dgspannew.append([arm[0],str(dgstart),str(dgend), seg[count][3]])
    return dgspannew

# Get span of DGs
def getDGspan(segs):
	DG_span = []
	DG_left_low = []
	DG_left_high = []
	DG_right_low = []
	DG_right_high = []
	for k,v in segs.items(): 
		if v[0][4] == set_span: 
			DG_left_low.append(v[0][1])
			DG_left_high.append(v[0][2])
			DG_right_low.append(v[1][1])
			DG_right_high.append(v[1][2])
	DG_left_list = ['Left', min(DG_left_low), max(DG_left_high), (max(DG_left_high) - min(DG_left_low) + 1)]
	DG_right_list = ['Right', min(DG_right_low), max(DG_right_high), (max(DG_right_high) - min(DG_right_low) + 1)]
	DG_span.append(DG_left_list) 
	DG_span.append(DG_right_list)
	return DG_span

# After reading in file into lines, segs were gotten with
segs = {}
for line in lines: getsegs(line,segs)

# Coverage is determined using the following parameters: 
# set_span = DG selected (e.g. set_span = 1 means DG_span and DG_segs will output information for DG1)
    
DG_count = int(dg_num) + 1

with open(sam_mod + "_endpoints.csv", 'w') as f:
    print("DG"+","+"coverage"+","+"Left"+","+"l_low"+","+"l_high"+","+"Right"+","+"r_low,"+"r_high", file=f)
    for i in range(0, DG_count):
        try:
            set_span = i

            # Check for DG in database
            DG_segs = []
            for k,v in segs.items():
               if v[0][4] == set_span:
                    DG_segs.append(v)

            # Span of left and right arms
            DG_span = getDGspan(segs)

            # Get endpoints for each DG, 0.5 refers to setting coverage at 50%
            endpoints = (str(set_span) + "," + str(len(DG_segs)) + "," + str(coveragenorm(DG_segs,DG_span,0.5)))
            end = re.sub('[^A-Za-z0-9]+',',', endpoints)[:-1]
            print(end, file=f)
            
        except:
            continue

os.remove(sam_nohead)